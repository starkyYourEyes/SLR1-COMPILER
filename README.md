## **编译原理课设**，简单文法的SLR1分析，C语言、C++实现

### 1.祖传文法 
S’-> S  
S-> CS  
S-> begin L end  
S-> A  
**C-> if B then**  
L-> S  
L-> K S  
K-> L;  
A-> id:=E  
E-> E + E  
E-> E _ E  
E-> E * E  
E-> E / E 
E-> -E  
E-> (E)  
E-> id  
B-> B or B  
B-> B and B  
B-> not B  
B-> (B)   
B-> E rop E  
B-> true  
B-> false  
> 其中:
S语句,L复合语句,A赋值语句,E算术表达式,B布尔表达式,rop关系运算符  
使用 '~' 进行行注释  
较祖传文法增加了两条，E-> E / E(除法), E-> E $ E(减法--为了尽量不改变祖传文法的符号，用了$)  
此外，个人认为，此祖传文法中的 S-> begin L end 中的 L 应该改为 K 比较好（但是显然祖传文法很难修改分毫）

### 2.识别文法中的终结符和非终结符并计算first集和follow集
1.扫描文法文件，识别非终结符和终结符。  
2.分别计算first集和follow集（文法简单，计算起来也相对简单），并输出到文件slr1_first_follow_set.txt  

### 3.词法分析
词法分析程序按行对源代码文件进行扫描，并识别出每一个单词和符号。所识别出的每一项为一个三元组`(value, type, line_number)`，其中第一项为这个符号，第二项为这个符号的类别，第三项为所在行号——方便报错定位。  
同时词法分析会识别出非法的符号，当词法分析识别出非法符号时，程序exit，并给出出错的行号列号。 

### 4.语法分析
语法分析根据词法分析的输出进行分析 *（语法分析之前先执行词法分析）*，此法输出的分析在lex_res.txt文件中。
语法分析按照**SLR(1)**分析过程，根据输入串、状态栈、符号栈以及ACTION表和GOTO表进行语法分析，指出源程序是否为该文法合法的句子。若源程序无法被语法分析程序识别，指出出错的行号。   
**移进-规约冲突** 采用 **指定优先级**的方式进行解决，如files/shift-reduce-conflict.txt文件中的冲突。
检测简单语法错误以及错误定位，如if和then以及begin和end的不匹配、结尾缺失end等。

### 5.语义分析
拉链——回填，以一个vector作为true链或false链，每次规约或者移进（then移进以及S->CS规约）的时候进行链的传递以及回填。   
检测一些简单错误并进行错误定位，如变量在定义之前使用、除以0错误等。